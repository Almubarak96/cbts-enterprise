// Package declaration - organizes classes within the student model package
package com.almubaraksuleiman.cbts.student.model;

// Import statements - JPA annotations, Lombok utilities, and related entities
import com.almubaraksuleiman.cbts.examiner.model.Question;
import jakarta.persistence.*;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

/**
 * Represents a student's interaction with a specific question during an exam session.
 * This entity tracks which questions are presented to the student, their answers,
 * and the completion status for each question within an exam.

 * This is a junction table that connects StudentExam and Question entities,
 * storing student-specific data for each question in an exam session.
 * @author Almubarak Suleiman
 * @version 1.0
 * @since 2025
 **/

@Entity // Marks this class as a JPA entity (persistent domain object)
@Table(name = "student_exam_question") // Specifies the database table name
@Data // Lombok: generates getters, setters, toString, equals, and hashCode methods
@NoArgsConstructor // Lombok: generates a no-arguments constructor
@AllArgsConstructor // Lombok: generates a constructor with all fields as arguments
@Builder // Lombok: enables the builder pattern for object creation
public class StudentExamQuestion {

    /**
     * Unique identifier for the student exam question record.
     * Auto-generated by the database using identity column strategy.
     * This is the primary key of the student_exam_question table.
     */
    @Id // Marks this field as the primary key
    @GeneratedValue(strategy = GenerationType.IDENTITY) // Auto-increment strategy
    private Long id;

    /**
     * The exam session that this question belongs to.
     * Many-to-One relationship: Many question responses can belong to one exam session.
     * Uses lazy fetching to improve performance (data loaded only when accessed).
     * The foreign key column "session_id" can be null for flexibility.
     */
    @ManyToOne(fetch = FetchType.LAZY) // Many question responses to one exam session
    @JoinColumn(name = "session_id", nullable = true) // Foreign key column, nullable for flexibility
    private StudentExam studentExam;

    /**
     * The actual question that the student is responding to.
     * Many-to-One relationship: Many student responses can reference one question.
     * Uses lazy fetching to improve performance.
     * The foreign key column "question_id" can be null for flexibility.
     */
    @ManyToOne(fetch = FetchType.LAZY) // Many student responses to one question
    @JoinColumn(name = "question_id", nullable = true) // Foreign key column, nullable for flexibility
    private Question question;

    /**
     * Flag indicating whether the student has provided an answer to this question.
     * True if the student has attempted to answer the question.
     * False if the question hasn't been addressed yet.
     * Useful for tracking completion progress and identifying unanswered questions.
     */
    private Boolean answered = false; // Defaults to false (not answered)

    /**
     * The student's answer to the question.
     * Storage format depends on the question type:
     * - Multiple Choice: Selected option (e.g., "Option C")
     * - Multiple Select: Comma-separated selected options (e.g., "Option A,Option C")
     * - Fill in the Blank: Text response
     * - Essay: Longer text response

     * Null if the question hasn't been answered yet.
     */
    private String savedAnswer;




    /**
     * Tracks the order of questions as they appear in the exam
     * This ensures consistent numbering between the question map and actual exam
     */
    @Column(name = "question_order")
    private Integer order;

    /**
     * Stores the shuffled order of answer choices for this specific question
     * in this specific exam session.

     * This field is crucial for maintaining consistent choice presentation when
     * 'shuffleChoices' is enabled for a test. It ensures that:

     * 1. **Consistency**: Once shuffled for a session, the choice order remains
     *    the same throughout the exam, even if the student navigates between
     *    questions, refreshes the page, or revisits the question later.

     * 2. **Persistence**: The shuffled order is preserved across browser sessions
     *    and page reloads because it's stored in the database.

     * 3. **Individualization**: Each student gets their own unique shuffle order
     *    for the same question, preventing answer pattern sharing.

     * How it works:
     * - When an exam starts and shuffleChoices is enabled, each question's choices
     *   are shuffled once using a consistent algorithm
     * - The shuffled order is stored in this field
     * - Whenever the question is displayed to the student, this stored order is used
     * - The original choices in the Question entity remain unchanged for other uses

     * Storage format:
     * - For comma-separated values: "Choice C,Choice B,Choice A,Choice D"
     * - For JSON arrays: "[\"Choice C\", \"Choice B\", \"Choice A\", \"Choice D\"]"

     * Example scenario:
     * Original choices: "A,B,C,D" where correct answer is "C"
     * Shuffled resource: "C,A,D,B"
     * - Student sees: Options [C, A, D, B] in that order
     * - Correct answer is still "C" (the text value, not the position)
     * - Grading compares student's selected text "C" with correct answer text "C"

     * This approach maintains test integrity while providing choice randomization.
     */
    @Column(name = "shuffled_choices") // Maps to shuffled_choices column in database
    private String shuffledChoices;

    /*
     * Potential additional fields that could be added:

     * // Timestamp when the question was first displayed to the student
     * private LocalDateTime displayTime;

     * // Timestamp when the student provided the answer
     * private LocalDateTime answerTime;

     * // Time spent on this specific question (in seconds)
     * private Integer timeSpentSeconds;

     * // Whether the answer was marked for review later
     * private Boolean markedForReview = false;

     * // Sequence number of the question in the exam
     * private Integer questionOrder;

     * // Points awarded for this question (after grading)
     * private Double pointsAwarded;

     * // Whether the answer was correct (for auto-graded questions)
     * private Boolean correct;

     * // Number of times the answer was changed
     * private Integer revisionCount = 0;
     */

    /*
     * Helper methods that could be added:

     * // Get the answer as a list (for multiple select questions)
     * public List<String> getAnswerAsList() {
     *     if (savedAnswer == null || savedAnswer.isEmpty()) {
     *         return new ArrayList<>();
     *     }
     *     return Arrays.asList(savedAnswer.split(","));
     * }

     * // Set the answer from a list (for multiple select questions)
     * public void setAnswerFromList(List<String> answers) {
     *     this.savedAnswer = String.join(",", answers);
     *     this.answered = !answers.isEmpty();
     * }

     * // Check if the answer is correct (for auto-graded questions)
     * public boolean isAnswerCorrect() {
     *     if (question != null && savedAnswer != null) {
     *         return savedAnswer.equals(question.getCorrectAnswer());
     *     }
     *     return false;
     * }

     * // Calculate time spent on question (if timestamps are available)
     * public Integer getTimeSpentSeconds() {
     *     if (displayTime != null && answerTime != null) {
     *         return (int) java.time.Duration.between(displayTime, answerTime).getSeconds();
     *     }
     *     return null;
     * }
     */

    /*
     * Example of builder pattern usage:
     * StudentExamQuestion examQuestion = StudentExamQuestion.builder()
     *     .studentExam(examSession)
     *     .question(mathQuestion)
     *     .answered(false)
     *     .savedAnswer(null)
     *     .build();
     */
}